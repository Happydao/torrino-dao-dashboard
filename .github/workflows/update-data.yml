name: Update Treasury Data

on:
  schedule:
    - cron: '0 4 * * *'  # 04:00 UTC
  workflow_dispatch:

permissions:
  contents: write

jobs:
  update-data:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.G_TOKEN }}

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          cache: 'npm'

      - name: Install dependencies
        run: |
          npm ci || true
          npm install puppeteer axios dotenv @solana/web3.js

      # Esegue gli script con log in diretta e costruisce logs.txt + logs.json
      - name: Run scripts with live logging + build logs.json & logs.txt
        shell: bash
        env:
          G_TOKEN: ${{ secrets.G_TOKEN }}
          HELIUS_API_KEY: ${{ secrets.HELIUS_API_KEY }}
          TENSOR_API_KEY: ${{ secrets.TENSOR_API_KEY }}
          GITHUB_RUN_ID: ${{ github.run_id }}
        run: |
          set -o pipefail

          START="$(date -u +%FT%TZ)"

          # Esecuzione con streaming su Actions e scrittura su file
          node scripts/totalvalue.js 2>&1 | tee out_totalvalue.log
          RC1=${PIPESTATUS[0]}

          node scripts/calculate.js 2>&1 | tee out_calculate.log
          RC2=${PIPESTATUS[0]}

          END="$(date -u +%FT%TZ)"

          # Writer inline (maschera SOLO le secret, non gli address pubblici)
          mkdir -p .github
          cat > .github/write-logs.mjs <<'NODE'
          import fs from 'fs';

          const runId = Number(process.env.GITHUB_RUN_ID || '0');
          const startedAt = process.env.STARTED_AT || new Date().toISOString();
          const finishedAt = process.env.FINISHED_AT || new Date().toISOString();
          const out1File = process.env.OUT1_FILE || 'out_totalvalue.log';
          const out2File = process.env.OUT2_FILE || 'out_calculate.log';
          const rc1 = Number(process.env.RC1 || 1);
          const rc2 = Number(process.env.RC2 || 1);
          const ok = (rc1 === 0 && rc2 === 0);

          const read = (p) => fs.existsSync(p) ? fs.readFileSync(p, 'utf8') : '';

          function escapeRegex(str) {
            return str.replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&');
          }
          function maskSecrets(s) {
            if (!s) return '';
            let out = s;

            // Maschera valori reali delle secret se accidentalmente stampati
            const secretKeys = [
              'HELIUS_API_KEY','TENSOR_API_KEY','G_TOKEN',
              'GITHUB_TOKEN','GH_TOKEN','ACTIONS_RUNTIME_TOKEN'
            ];
            for (const k of secretKeys) {
              const v = process.env[k];
              if (v && typeof v === 'string' && v.length > 0) {
                out = out.replace(new RegExp(escapeRegex(v), 'g'), '[REDACTED]');
              }
            }

            // Maschera pattern comuni di credenziali in chiaro
            out = out.replace(/([?&#]api[-_]?key=)[^&\s]+/gi, '$1[REDACTED]');
            out = out.replace(/(Authorization:\s*Bearer\s+)[^\s]+/gi, '$1[REDACTED]');
            out = out.replace(/(\bBearer\s+)[A-Za-z0-9._-]+/gi, '$1[REDACTED]');
            out = out.replace(/(\btoken=)[A-Za-z0-9._-]+/gi, '$1[REDACTED]');

            // NIENTE redazione generica: address/mint sono pubblici.
            return out;
          }

          const out1 = maskSecrets(read(out1File));
          const out2 = maskSecrets(read(out2File));

          const raw = [
            '=== Update Treasury Data ===',
            `Started at: ${startedAt}`,
            '',
            '----- totalvalue.js -----',
            out1,
            '',
            '----- calculate.js -----',
            out2,
            '',
            `Finished at: ${finishedAt}`,
            `Status: ${ok}`
          ].join('\n');

          fs.writeFileSync('logs.txt', raw, 'utf8');

          const payload = {
            runId,
            startedAt,
            finishedAt,
            ok,
            steps: [
              { name: 'totalvalue.js', exitCode: rc1, output: out1 },
              { name: 'calculate.js', exitCode: rc2, output: out2 }
            ],
            raw
          };
          fs.writeFileSync('logs.json', JSON.stringify(payload, null, 2), 'utf8');

          // Copie storiche (per GitHub Pages)
          const tsSafe = startedAt.replace(/:/g, '-');
          fs.mkdirSync('logs', { recursive: true });
          fs.copyFileSync('logs.txt', `logs/${tsSafe}_run-${runId}.txt`);
          fs.copyFileSync('logs.json', `logs/${tsSafe}_run-${runId}.json`);
          NODE

          STARTED_AT="$START" \
          FINISHED_AT="$END" \
          RC1="$RC1" RC2="$RC2" \
          OUT1_FILE="out_totalvalue.log" \
          OUT2_FILE="out_calculate.log" \
          node .github/write-logs.mjs

          echo "----- logs.txt (prime 50 righe) -----"
          head -n 50 logs.txt || true
          echo "----- logs.json (bytes) -----"
          wc -c logs.json || true

      - name: Commit and push changes
        if: always()
        env:
          G_TOKEN: ${{ secrets.G_TOKEN }}
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          # Aggiunge anche i log e l'output aggregato
          git add data.json totalvalue_output.json logs.txt logs.json logs/

          if git diff --cached --quiet; then
            echo "Nessuna modifica da committare."
          else
            git commit -m "ðŸ”„ Update data.json + publish logs [skip ci]"
            git push origin ${{ github.ref_name }}
          fi
